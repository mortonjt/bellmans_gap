

#ifndef _GRAMMAR_VM_FUNCTION_COMPILER_HH_
#define _GRAMMAR_VM_FUNCTION_COMPILER_HH_

#include <vector>
#include <set>

#include "../algebra.hh"
#include "../loc.hh"
#include "../fn_def.hh"
#include "../fn_arg.hh"
#include "../statement/base.hh"
#include "../statement/fn_call.hh"
#include "../statement/while.hh"
#include "../statement.hh"
#include "../expr_fwd.hh"
#include "../hashtable.hh"
#include "../var_acc.hh"

#include "../cfg/cfg.hh"
#include "grammar_vm.hh"
#include "grammar_vm_code.hh"
#include "var_info_item.hh"
#include "../util/symbol_table.cc"


namespace AmbiguityCFG {
	
	
	class GrammarVMFunctionCompiler {
		
		private:
			
			// Holds a reference to the algebra in which the function
			// which is processed by this FnDefProcessor is defined.
			// This reference is needed because of function calls to
			// other algebra functions out of an algebra function itself.
			Algebra* algebra;
			
			// The name of the algebra function that is processed by
			// this instance. This name can be used e.g. in error messages.
			std::string* currentAlgebraFunctionName;
			
			// We need a map that stores all results computed so far for
			// each variable declared in the algebra function. Each variable
			// declaration will add an entry to this hashtable, and each
			// append-method-call to an identifier will update the results
			// computed so far for that variable.
			Util::SymbolTable<std::string, VarInfoItem*>* declaredVariables;
			
			// This flag is set true, when a return-statement is reached
			// in the current block.
			bool controlFlowReturned;
			
			// This is the code generated by this FnDefProcessor instance,
			// which will be interpreted by the GrammarVM and produce the
			// CFG fragment that is generated by this command.
			GrammarVMCode* grammarVMCode;
			
			// All resulting productions are listed in this variable.
			std::list<CFG::Base*> resultProductions;
			
			// Clears all internal data structures and prepares this instance
			// for reuse.
			void clear();
			
			
		public:
			
			GrammarVMFunctionCompiler (Algebra* algebra);
			~GrammarVMFunctionCompiler();
			
			// Main entry point for the processing of a function definition.
			GrammarVMCode* processFnDef (std::string* algebraFunctionName);
			
			
		private:
			
			void processStatementList (std::list<Statement::Base*> stmts);
			
			void processStatement (Statement::Base *stmt);
			void processStatement (Statement::Return *stmt);
			void processStatement (Statement::Fn_Call *stmt);
			void processStatement (Statement::Var_Decl *stmt);
			void processStatement (Statement::Var_Assign *stmt);
			void processStatement (Statement::Block* stmt);
			void processStatement (Statement::If* stmt);
			void processStatement (Statement::While* stmt);
			void processStatement (Statement::For* stmt);
			void processStatement (Statement::Foreach* stmt);
			
			void processAppendCall (std::list<Expr::Base*> &args);
			void processLoopStatement (Statement::Block_Base* bb);
			
			void processExpr (Expr::Base* expr);
			
			VarDeclInfo* processVarAccess (Expr::Vacc* varAccess);
			VarInfoItem* processVarAccess (Var_Acc::Base* acc);
			VarInfoItem* processVarAccess (Var_Acc::Plain* acc);
			VarInfoItem* processVarAccess (Var_Acc::Comp* acc);
			VarInfoItem* processVarAccess (Var_Acc::Array* acc);
			
			// Returns the variable declaration information item for
			// a given variable name, or throws an exception if no
			// variable with that name has been defined so far.
			VarInfoItem* getVarDeclInfo (Loc location, std::string* varName);
			
			std::string* processVarAccess_ (Expr::Vacc* varAccess);
			VarInfoItem* processVarAccess_ (Var_Acc::Base* acc);
			VarInfoItem* processVarAccess_ (Var_Acc::Plain* acc);
			VarInfoItem* processVarAccess_ (Var_Acc::Comp* acc);
			VarInfoItem* processVarAccess_ (Var_Acc::Array* acc);
			
			VarInfoItem* getVarDeclInfo_ (Loc location, std::string* varName);
			
			
	};
	
	
}


#endif	// ifndef _GRAMMAR_VM_FUNCTION_COMPILER_HH_

