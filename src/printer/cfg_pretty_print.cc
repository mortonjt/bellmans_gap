

#include "cfg_pretty_print.hh"


#include <iostream>
#include <list>
#include <sstream>
#include <iomanip>
#include <cassert>

#include "../log.hh"


Printer::CFGPrettyPrint::CFGPrettyPrint(std::ostream &oStream)
	: oStream (oStream), taggedPrintMode (false) {
}


void Printer::CFGPrettyPrint::setCommandLineCall (std::string* commandLineCall){
	this->commandLineCall = commandLineCall;
}


void Printer::CFGPrettyPrint::prettyPrint (CFG::CFG *cfg) {
	// print some header containing information about the compiler
	// call that generated the grammar output
	oStream << "/* This grammar was generated by gapc with the command   */" << std::endl;
	oStream << "/*                                                       */" << std::endl;
	oStream << "/* " << *this->commandLineCall << " */" << std::endl;
	oStream << "/*                                                       */" << std::endl;
	oStream << "/* This file can be used as direct input to the tool     */" << std::endl;
	oStream << "/* found at http://www.brics.dk/grammar/, or by using    */" << std::endl;
	oStream << "/* the online version at                                 */" << std::endl;
	oStream << "/* http://services.brics.dk/java/grammar/demo.html       */" << std::endl;
	oStream << std::endl;
	oStream << std::endl;
	
	
	// Start with all regular expressions.
	std::list<CFG::RegularExpression*> regexList = cfg->getRegularExpressions();
	// if no expressions are in the list, omit the banner
	if (regexList.begin() != regexList.end()) {
		oStream << "/* Definitions of regular expressions                    */" << std::endl;
		oStream << std::endl;
	}
	for (std::list<CFG::RegularExpression*>::iterator i = regexList.begin(); i != regexList.end(); ++i) {
		ppRegularExpressionRule (*i);
	}
	
	oStream << std::endl;
	oStream << std::endl;
	oStream << "/* The grammar. Note, the first rule marks the axiom.    */" << std::endl;
	oStream << std::endl;
	// Then print out the grammar.
	std::list<CFG::GrammarProduction*> productions = cfg->getProductions();
	for (std::list<CFG::GrammarProduction*>::iterator i = productions.begin(); i != productions.end(); ++i) {
		ppGrammarProduction (*i);
	}
	
	// add a last end-line
	oStream << std::endl;
}


void Printer::CFGPrettyPrint::ppGrammarProduction (CFG::GrammarProduction *prod) {
	// Create the padding string which length is the same as that
	// of the grammar production's name.
	std::string* padding = new std::string ("");
	std::stringstream strstrm;
	strstrm << std::setw (prod->lhs->getName()->length()) << " ";
	padding = new std::string (strstrm.str());
	
	// first pring the left-hand-side of the production...
	ppNonTerminal (prod->lhs);
	oStream << " : ";
	// ...then the right-hand-side
	ppProductionAlternative (padding, prod->rhs);
	oStream << std::endl;
}


void Printer::CFGPrettyPrint::ppBase (std::string *padding, CFG::Base *b) {
	// check parameters first
	assert (b != NULL);
	// then do some work
	switch (b->getType()) {
		case CFG::BASE_WRAPPER: {
			if (taggedPrintMode) std::cout << "<WRAPPER>";
			ppBaseWrapper (padding, (CFG::BaseWrapper*)b);
			break;
		}
		case CFG::SNAPSHOT: {
			if (taggedPrintMode) std::cout << "<SNAPSHOT>";
			ppSnapshot (padding, (CFG::Snapshot*)b);
			break;
		}
		case CFG::EPSILON: {
			if (taggedPrintMode) std::cout << "<EPSILON>";
			ppEpsilon ((CFG::Epsilon*)b);
			break;
		}
		case CFG::TERMINAL: {
			if (taggedPrintMode) std::cout << "<TERMINAL>";
			ppTerminal ((CFG::Terminal*)b);
			break;
		}
		case CFG::NONTERMINAL: {
			if (taggedPrintMode) std::cout << "<NONTERMINAL>";
			ppNonTerminal ((CFG::NonTerminal*)b);
			break;
		}
		case CFG::REGULAR_EXPRESSION: {
			if (taggedPrintMode) std::cout << "<REGULAR_EXPRESSION>";
			ppRegExpName ((CFG::RegularExpression*)b);
			break;
		}
		case CFG::PRODUCTION_SEQUENCE: {
			if (taggedPrintMode) std::cout << "<PRODUCTION_SEQUENCE>";
			ppProductionSequence (padding, (CFG::ProductionSequence*)b);
			break;
		}
		case CFG::PRODUCTION_ALTERNATIVE: {
			if (taggedPrintMode) std::cout << "<PRODUCTION_ALTERNATIVE>";
			ppProductionAlternative (padding, (CFG::ProductionAlternative*)b);
			break;
		}
		case CFG::BASE:
		default: {
			throw LogError ("gap-00487: Internal: Unandled CFG node type");
		}
	}
}


void Printer::CFGPrettyPrint::ppBaseWrapper (std::string* padding, CFG::BaseWrapper* w) {
	ppBase (padding, w->getWrappedBase());
}


void Printer::CFGPrettyPrint::ppSnapshot (std::string *padding, CFG::Snapshot* s) {
	// 
	oStream << "[";
	ppBase (padding, s->getOriginal());
	oStream << " (+) ";
	ppBase (padding, s->getChanges());
	oStream << "]";
}


void Printer::CFGPrettyPrint::ppEpsilon (CFG::Epsilon *e) {
	// The epsilon must be omitted in the output according to
	// the target file format, thus:
	//oStream << "<epsilon>";
	oStream << "/* empty */";
}


void Printer::CFGPrettyPrint::ppTerminal (CFG::Terminal *t) {
	oStream << "\"" << *t->getValue() << "\"";
}


void Printer::CFGPrettyPrint::ppNonTerminal (CFG::NonTerminal *nt) {
	oStream << *nt->getName();
}


void Printer::CFGPrettyPrint::ppProductionSequence (std::string *padding, CFG::ProductionSequence *seq) {
	bool firstRun = true;
	for (int i = 0; i < seq->getSize(); i++) {
		if (!firstRun) {
			oStream << " ";
		}
		ppBase (padding, seq->elementAt (i));
		firstRun = false;
	}
}


void Printer::CFGPrettyPrint::ppProductionAlternative (std::string *padding, CFG::ProductionAlternative *alt) {
	bool firstRun = true;
	for (CFG::ProductionAlternative::iterator i = alt->begin(); i != alt->end(); i++) {
		if (!firstRun) {
			if (padding != NULL) {
				oStream << std::endl << *padding;
			}
			oStream << " | ";
		}
		ppBase (padding, *i);
		firstRun = false;
	}
}


void Printer::CFGPrettyPrint::ppRegularExpressionRule (CFG::RegularExpression* regexp) {
	// print the identifier first
	oStream << *regexp->getName() << " = " << *regexp->getExpression();
	CFG::Bounds* bounds = regexp->getBounds();
	if (bounds != NULL && (bounds->getLowerBound() != CFG::Bounds::UNDEFINED || bounds->getUpperBound() != CFG::Bounds::UNDEFINED)) {
		oStream << "{";
		if (bounds->getLowerBound() != CFG::Bounds::UNDEFINED) {
			oStream << bounds->getLowerBound() << ",";
		}
		if (bounds->getUpperBound() != CFG::Bounds::UNDEFINED) {
			oStream << bounds->getUpperBound();
		}
		oStream << "}";
	}
	oStream << std::endl;
}


void Printer::CFGPrettyPrint::ppRegExpName (CFG::RegularExpression* regexp) {
	oStream << "<" << *regexp->getName() << ">";
}


